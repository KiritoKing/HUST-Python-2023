# 练习题说明

### P1: 阶乘问题（factorial）

阶乘问题是一个基础的分治问题，可以用递归和非递归的方法求解，个人更倾向于使用非递归方法来避免调用栈开销。

需要注意的是，100的阶乘是一个很大的整数，在其他语言中可能需要担心溢出，而Python中则不用担心。

### P2: 青蛙跳台阶

>  一只青蛙一次只能跳一级或者两级台阶，青蛙跳到100级台阶有多少中跳法？

这是一个经典的分治问题，与斐波那契函数相似，不过斐波那契数列的前两项都是1，而这个数列的前两项分别为1和2。

### P3：生日问题

>  100个人集中在一个房间，至少有两个人生日相同的概率有多大？

这也是一道经典的分治题目，不过与概率相关，具体实现与[P1](#P1: 阶乘问题（factorial）)类似

### P4：特殊数字求解

这道题直接使用遍历法即可完成，这里使用了一些Python的语言特性，使用字符串比较而非数值运算实现了该功能。

```python
l = [i for i in range(10000, 100000) if str(i * 4) == str(i)[::-1]]
```

### P5：概率法求Pi

**蒙特卡洛(Monte Carlo)方法**，又称随机抽样或统计试验方法。当所求解的问题是某种事件出现的概率，或某随机变量的期望值时，可以通过某种“试验”方法求解。

构造一个单位正方形和一个单位圆的1/4，往整个区域内随机投入点，根据点到原点的距离判断点是落在1/4的圆内还是在圆外，从而根据落在两个不同区域的点的数目，求出两个区域的比值。如此一来，就可以求出1/4单位圆的面积，从而求出圆周率π。

### P6：猜岁数问题

>  一普查员问一位女士，“你有多少个孩子，他们多少岁？”女士回答：“我有三个孩子，他们的岁数相乘是36，岁数相加就等于旁边房间的门牌号码.”普查员立刻走到隔邻，看了一看，回来说”我还需要多少资料.”女士回答：“我现在很忙，我最大的孩子正在楼上睡觉”普查员说：”谢谢，我己知道了问题那三个孩子的岁数是多少？

这是一道数学逻辑题目，其实并不需要用编程语言来实现，以下是思路：**先找出所有积为36的可能组合，再根据和信息筛选。**

首先我们分下女人的话，她说：“我有三个孩子，他们的岁数相乘是36”，因此我们可以对36做质数分解，即：**36 = 1 \* 2 \* 2 \* 3 \* 3**；女人的第二句话“岁数相加等于旁边屋的门牌号码”，我们对3个数相乘组成36的情况做一下分析，得出的结果如下：

![img](https://img-blog.csdn.net/20150811145622204?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

普查员在查看门牌号码之后说“我还需要一些资料”，说明知道和，但是解不是唯一的情况，因此我们可以推测出**三个孩子岁数相加等于13**，也就是1-6-6和2-2-9这两种情况，这时女人又说了一句“我最大的孩子正在楼上睡觉”，从这句话可以推出只有一个最大，所以可能的结果是：**2岁、2岁、9岁**。

### P7：序列和最小

这是本题中最难的一道题，可以通过转化成 **“将长度为2n的无序序列分成两个长度为n的序列，并使它们的序列和的差最小”** 问题来解决。

最开始尝试了贪心算法（先排序，然后移动能使它们的差改变最大的数，直到情况反转），但是效果不佳，遂在网上寻找思路。

详细思路参考[力扣题解](https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/zui-jie-jin-mu-biao-zhi-de-zi-xu-lie-he-m0sq3/)，个人倾向于使用DP方法记录最优解，但这对数字较大的情况无效。

### P8：帽子颜色问题

> 有三顶红帽子和两顶白帽子。将其中的三顶帽子分别戴在A、B、C三人头上。这三人每人都只能看见其他两人头上的帽子，但看不见自己头上戴的帽子，并且也不知道剩余的两顶帽子的颜色。问A:“你戴的是什么颜色的帽子？”A回答说：“不知道。”接着，又以同样的问题问B。B想了想之后，也回答说：“不知道。”最后问C。C回答说：“我知道我戴的帽子是什么颜色了。”当然，C是在听了A、B的回答之后而作出回答的。请尝试用编程方法解答此问题。

这是一道数学逻辑题目，其实并不需要用编程语言来实现，以下是思路：

对于题目给出的三顶红帽子和两顶白帽子条件，ABC三人中一定有一人会带红帽子。

首先问A，A如果不知道自己头顶帽子的颜色，首先可以想到A看到的不是两顶白色帽子（若看到两顶白色则一定能确定自己头上的帽子是红色）；

再问B，B也说不知道自己头上帽子的颜色，同理可以知道B看到的一定也不是两顶白色帽子；

然后C说他知道自己帽子的颜色了，首先若AB都为白色帽子，C看到后一定能想到自己的帽子颜色是红色，此时的情况A和B看到的都是一红一白，故AB无法判断；其次，若C的帽子为红色，AB两人的帽子为一红一白，此时假设A红B白，A看到的则是一红一白，B看到的是两红，故AB两人之前无法判断AB自己帽子的颜色条件依然成立。

### P9：汉诺塔问题

汉诺塔问题可以使用递归算法来解决。假设有三个柱子，分别为起始柱（源柱）、中间柱和目标柱，有n个圆盘从小到大按顺序放在起始柱上，要把它们移动到目标柱上，其中每次只能移动一个圆盘，且大圆盘不能放在小圆盘上面。

具体解决思路如下：

1. 当只有一个圆盘时，直接将其从源柱移动到目标柱上即可。
2. 当有两个以上的圆盘时，可以将前n-1个圆盘看作一个整体，先将这个整体从起始柱移动到中间柱上，然后将第n个圆盘从起始柱移动到目标柱上，最后将前n-1个圆盘从中间柱移动到目标柱上。
3. 将前n-1个圆盘从起始柱移动到中间柱，可以看作是一个递归问题，递归结束的条件是只剩下一个圆盘时，这时可以直接将其从起始柱移动到目标柱上。

递归过程中需要不断调用自身函数，并在每次递归中将圆盘从一个柱子移动到另一个柱子上。

### P10：八皇后问题

八皇后问题是一个经典的回溯算法问题，它的目标是在8x8的棋盘上放置8个皇后，使得任意两个皇后都不在同一行、同一列或同一斜线上。下面是解决八皇后问题的思路：

1. 用一个长度为8的列表 queen_list 存放每行皇后的位置，初始值全部为 -1。

2. 从第 0 行开始逐行放置皇后，对于每一行，从第 0 列开始尝试放置皇后，如果某一列可以放置，则将 queen_list 对应位置赋值为该列号，并尝试放置下一行皇后。

3. 如果某一行无法放置皇后，或者已经放置了8个皇后，则回溯到上一行，继续尝试下一个位置。

4. 当 queen_list 最后一项被赋值后，即8个皇后都被成功放置，记录这个方案并继续回溯，找到所有合法的方案。

5. 在放置皇后时，需要判断当前位置是否与已放置的皇后位置冲突，只有不冲突才能继续尝试下一行放置。

6. 可以用递归来实现放置皇后的过程，递归函数的参数为当前要放置皇后的行数和 queen_list 列表。

7. 回溯算法通常会用到栈来保存当前状态，回溯时将栈顶元素弹出即可恢复到上一个状态。在本问题中，可以使用递归函数的调用栈来实现状态的保存和回溯。

总体来说，八皇后问题是一个典型的回溯算法问题，需要不断尝试不同的方案，并在每次尝试后判断当前状态是否合法，如果不合法就回溯到上一个状态。由于八皇后问题的搜索空间非常大，因此需要采用一些剪枝技巧来减少搜索次数，提高算法效率。